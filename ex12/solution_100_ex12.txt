// Für unseren lieben Patrick ohne Word eine .txt Datei!!

Aufgabe 1: Composite Pattern erkennen

java.awt:
	Component ist java.awt.Component
		Denn es ist abstract. Es enthaelt einige Methoden, welche die Leave
	Composite ist java.awt.Container
		Die Klasse enthält eine java.util.List<Component> und implementiert die 
		Methoden add(Component), remove(Component), remove(int) und getComponent(int), 
		welches als das getChild(int) im Skript fungiert.
	Leaves sind Subklassen von Component, zum Beispiel java.awt.Button und java.awt.Label
	
	Warum wurde hier das Composite pattern gewählt?
		Eine graphische java.awt Benutzeroberfläche kann viele Elemente enthalten.
		Diese sollen auch als Gruppen behandelt werden können.
		

Aufgabe 2:

javax.xml.parsers:

SAXParserFactory fungiert als AbstractFactory. 
Eine ConreteFactory kann durch die statische Methode newInstance(...) erzeugt werden.
die FactoryMethod newSAXParser erzeugt einen SAXParser. SAXParser ist das AbstractProduct-Interface, 
concrete Products müssen implementiert werden.

javax.xml.transform: 

Eine AbstractFactory ist TransformerFactory, mit FactoryMethod newTransformer(). 
Templates und SAXTransformerFactory sind concreteFactories. Templates ist das Interface, 
dass im Sinne des Abstract Factory Patterns ein AbtractProduct ist, Transformer dagegen ein
concreteProduct.

javax.xml.xpath:

Die XPathFactory ist eine AbstractFactory. Mit deren statischer Methode newInstance(...) können conreteFactories erzeugt werden.
FactoryMethod ist newXPath(), XPath ist das ConreteProduct; XPathExpression etwa, ein abstractProduct-Interface.

